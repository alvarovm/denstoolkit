/*
 *  solcudatools.cu
 *
 *
 *  Created by Juan Manuel Solano Altamirano on 21/07/13.
 *  Copyright 2013. All rights reserved.
 *
 */

#ifndef _SOL_CUDA_TOOLS_CU_
#define _SOL_CUDA_TOOLS_CU_
#include <iostream>
using std::cout;
using std::endl;
#include <string>
using std::string;

#include "solcudatools.cuh"
#include "solmemhand.h"

//**************************************************************************************************
extern "C" bool alloc1DRealArrayInGPU(int ddim,solreal **dev_Ptr)
{
   if (ddim<1) {
      cout << "Error: Trying to allocate an array with dim<1! Returning false." << endl;
      return false;
   }
   if (*dev_Ptr!=NULL) {
      cout << "Error: The value of the pointer is not null!" << endl;
      return false;
   }
   unsigned int mem_size=sizeof(solreal)*ddim;
   checkCudaErrors(cudaMalloc((void **) &(*dev_Ptr), mem_size));
   return true;
}
//**************************************************************************************************
extern "C" void dealloc1DRealArrayInGPU(solreal **dev_Ptr)
{
   if (*dev_Ptr!=NULL) {
      checkCudaErrors(cudaFree(*dev_Ptr));
      *dev_Ptr=NULL;
   }
   return;
}
//**************************************************************************************************
extern "C" void copy1DRealArrayToGPU(int dim,solreal** hst_Ptr,solreal** dev_Ptr)
{
   unsigned int mem_size=sizeof(real)*dim;
   checkCudaErrors(cudaMemcpy(*dev_Ptr, *hst_Ptr, mem_size, cudaMemcpyHostToDevice));
   return;
}
//**************************************************************************************************
extern "C" void copy1DRealArrayToHost(int dim,solreal** dev_Ptr,solreal** hst_Ptr)
{
   unsigned int mem_size=sizeof(real)*dim;
   checkCudaErrors(cudaMemcpy(*hst_Ptr, *dev_Ptr, mem_size,cudaMemcpyDeviceToHost));
   return;
}
//**************************************************************************************************
extern "C" bool alloc1DIntArrayInGPU(int ddim,int **dev_Ptr)
{
   if (ddim<1) {
      cout << "Error: Trying to allocate an array with dim<1! Returning false." << endl;
      return false;
   }
   unsigned int mem_size=sizeof(int)*ddim;
   checkCudaErrors(cudaMalloc((void **) &(*dev_Ptr), mem_size));
   return true;
}
//**************************************************************************************************
extern "C" void dealloc1DIntArrayInGPU(int **dev_Ptr)
{
   if (*dev_Ptr!=NULL) {
      checkCudaErrors(cudaFree(*dev_Ptr));
      *dev_Ptr=NULL;
   }
   return;
}
//**************************************************************************************************
extern "C" void copy1DIntArrayToGPU(int dim,int** hst_Ptr,int** dev_Ptr)
{
   unsigned int mem_size=sizeof(int)*dim;
   checkCudaErrors(cudaMemcpy(*dev_Ptr, *hst_Ptr, mem_size, cudaMemcpyHostToDevice));
   return;
}
//**************************************************************************************************
extern "C" void copy1DIntArrayToHost(int dim,int** dev_Ptr,int** hst_Ptr)
{
   unsigned int mem_size=sizeof(int)*dim;
   checkCudaErrors(cudaMemcpy(*hst_Ptr, *dev_Ptr, mem_size,cudaMemcpyDeviceToHost));
   return;
}
//**************************************************************************************************
cudaDual1DRealArray::cudaDual1DRealArray()
{
   dim=d_dim=0;
   bPG=tPB=0;
   h=d=NULL;
}
//**************************************************************************************************
cudaDual1DRealArray::~cudaDual1DRealArray()
{
   //cout << "Entering destructor" << endl;
   //cout << "h= " << h << endl;
   //cout << "d= " << d << endl;
   dealloc1DRealArray(h);
   dealloc1DRealArrayInGPU(&d);
   dim=d_dim=0;
   bPG=tPB=0;
   //cout << "After dealloc:" << endl;
   //cout << "h= " << h << endl;
   //cout << "d= " << d << endl;
}
//**************************************************************************************************
bool cudaDual1DRealArray::mountMe(int nn)
{
   dim=nn;
   d_dim=((dim+(BASETHREADSPERBLOCK-1))/BASETHREADSPERBLOCK)*BASETHREADSPERBLOCK;
   tPB=BASETHREADSPERBLOCK;
   bPG=(d_dim + tPB - 1)/tPB;
   bool res;
   res=alloc1DRealArray("h",d_dim,h);
   res=(res&&(alloc1DRealArrayInGPU(d_dim,&d)));
   copyMeToGPU();
   //cout << "d: " << d << endl;
   return res;
}
//**************************************************************************************************
void cudaDual1DRealArray::copyMeToGPU(void)
{
   copy1DRealArrayToGPU(d_dim,&h,&d);
   return;
}
//**************************************************************************************************
void cudaDual1DRealArray::copyMeToHost(void)
{
   copy1DRealArrayToHost(d_dim,&d,&h);
}
//**************************************************************************************************
void cudaDual1DRealArray::zerosDev(void)
{
   setRealArrayToZerosInGPU(d_dim,bPG,tPB,&d);
   return;
}
//**************************************************************************************************
void cudaDual1DRealArray::zerosHst(void)
{
   for (int i=0; i<d_dim; i++) {h[i]=0.0e0;}
   return;
}
//**************************************************************************************************
void cudaDual1DRealArray::setValDev(const solreal val)
{
   krnlSetValReal<<<bPG,tPB>>>(dim,val,d);
   return;
}
//**************************************************************************************************
void cudaDual1DRealArray::setValHst(const solreal val)
{
   for (int i=0; i<dim; i++) {h[i]=val;}
   return;
}
//**************************************************************************************************
void testFunctionInGPU(cudaDual1DRealArray &v)
{
   //krnlTst<<<v.bPG,v.tPB>>>(v.d_dim,(v.d));
   testFunctionInGPUCSt(v.d_dim,v.tPB,v.bPG,&(v.d));
   v.copyMeToHost();
   return;
}
//**************************************************************************************************
extern "C" void testFunctionInGPUCSt(int dim,int bPerGrid,int tPerBlock,solreal **dev_Ptr)
{
   krnlTst<<<bPerGrid,tPerBlock>>>(dim,*dev_Ptr);
   return;
}
//**************************************************************************************************
cudaSingle1DRealArray::cudaSingle1DRealArray()
{
   dim=d_dim=0;
   bPG=tPB=0;
   d=NULL;
}
//**************************************************************************************************
cudaSingle1DRealArray::~cudaSingle1DRealArray()
{
   dealloc1DRealArrayInGPU(&d);
   dim=d_dim=0;
   bPG=tPB=0;
}
//**************************************************************************************************
bool cudaSingle1DRealArray::mountMe(int nn)
{
   dim=nn;
   d_dim=((dim+(BASETHREADSPERBLOCK-1))/BASETHREADSPERBLOCK)*BASETHREADSPERBLOCK;
   tPB=BASETHREADSPERBLOCK;
   bPG=(d_dim + tPB - 1)/tPB;
   return alloc1DRealArrayInGPU(d_dim,&d);
}
//**************************************************************************************************
void cudaSingle1DRealArray::zeros(void)
{
   setRealArrayToZerosInGPU(d_dim,bPG,tPB,&d);
}
//**************************************************************************************************
extern "C" void setRealArrayToZerosInGPU(int dim,int bPerGrid,int tPerBlock,solreal **dev_Ptr)
{
   krnlSetToZerosReal<<<bPerGrid,tPerBlock>>>(*dev_Ptr);
   return;
}
//**************************************************************************************************
cudaDual1DIntArray::cudaDual1DIntArray()
{
   dim=d_dim=0;
   bPG=tPB=0;
   h=d=NULL;
}
//**************************************************************************************************
cudaDual1DIntArray::~cudaDual1DIntArray()
{
   //cout << "Entering destructor" << endl;
   //cout << "h= " << h << endl;
   //cout << "d= " << d << endl;
   dealloc1DIntArray(h);
   dealloc1DIntArrayInGPU(&d);
   dim=d_dim=0;
   bPG=tPB=0;
   //cout << "After dealloc:" << endl;
   //cout << "h= " << h << endl;
   //cout << "d= " << d << endl;
}
//**************************************************************************************************
bool cudaDual1DIntArray::mountMe(int nn)
{
   dim=nn;
   d_dim=((dim+(BASETHREADSPERBLOCK-1))/BASETHREADSPERBLOCK)*BASETHREADSPERBLOCK;
   tPB=BASETHREADSPERBLOCK;
   bPG=(d_dim + tPB - 1)/tPB;
   bool res;
   res=alloc1DIntArray("h",d_dim,h);
   res=(res&&(alloc1DIntArrayInGPU(d_dim,&d)));
   copyMeToGPU();
   //krnlTstInt<<<bPG,tPB>>>(dim,d);
   //copyMeToHost();
   //cout << "d: " << d << endl;
   return res;
}
//**************************************************************************************************
void cudaDual1DIntArray::copyMeToGPU(void)
{
   copy1DIntArrayToGPU(d_dim,&h,&d);
   return;
}
//**************************************************************************************************
void cudaDual1DIntArray::copyMeToHost(void)
{
   copy1DIntArrayToHost(d_dim,&d,&h);
}
//**************************************************************************************************
void cudaDual1DIntArray::zerosDev(void)
{
   setIntArrayToZerosInGPU(d_dim,bPG,tPB,&d);
   return;
}
//**************************************************************************************************
void cudaDual1DIntArray::zerosHst(void)
{
   for (int i=0; i<d_dim; i++) {h[i]=0;}
   return;
}
//**************************************************************************************************
extern "C" void setIntArrayToZerosInGPU(int dim,int bPerGrid,int tPerBlock,int **dev_Ptr)
{
   krnlSetToZerosInt<<<bPerGrid,tPerBlock>>>(*dev_Ptr);
   return;
}
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
//**************************************************************************************************
__global__ void krnlSetValReal(const int dim,const solreal val,solreal *dev_Ptr)
{
   unsigned int ptid = blockDim.x * blockIdx.x +threadIdx.x;
   if (ptid<dim) {dev_Ptr[ptid]=val;}
   return;
}
//**************************************************************************************************
__global__ void krnlSetToZerosInt(int *dev_Ptr)
{
   unsigned int ptid = blockDim.x * blockIdx.x +threadIdx.x;
   dev_Ptr[ptid]=0;
   return;
}
//**************************************************************************************************
__global__ void krnlSetToZerosReal(solreal *dev_Ptr)
{
   unsigned int ptid = blockDim.x * blockIdx.x +threadIdx.x;
   dev_Ptr[ptid]=0.0e0;
   return;
}
//**************************************************************************************************
__global__ void krnlTst(int dim,solreal *dev_Ptr)
{
   unsigned int ptid = blockDim.x * blockIdx.x +threadIdx.x;
   dev_Ptr[ptid]=solreal(ptid);
   return;
}
//**************************************************************************************************
__global__ void krnlTstInt(int dim,int *dev_Ptr)
{
   unsigned int ptid = blockDim.x * blockIdx.x +threadIdx.x;
   if (ptid<dim) {
      dev_Ptr[ptid]=ptid;
   } else {
      dev_Ptr[ptid]=0;
   }
   return;
}
//**************************************************************************************************
__device__ double atomicAdd(double* address, double val)
{
   unsigned long long int* address_as_ull =
   (unsigned long long int*)address;
   unsigned long long int old = *address_as_ull, assumed;
   do {
      assumed = old;
      old = atomicCAS(address_as_ull, assumed,
                      __double_as_longlong(val +
                                           __longlong_as_double(assumed)));
   } while (assumed != old);
   return __longlong_as_double(old);
}
//**************************************************************************************************
#endif /* defined(_SOL_CUDA_TOOLS_CU_) */




